
public class Solution
{
    private int?[] _numberOfJumps;
    private bool?[] _hasJumpedForwardToReachThisSpot;
    private List<int> _forbidden;
    private int _min;
    private int _max;
    private int _jumpForward;
    private int _jumpBackward;
    private int _x;

    // https://leetcode.com/problems/minimum-jumps-to-reach-home/
    public int MinimumJumps(int[] forbidden, int a, int b, int x)
    {
        if (x == 0)
            return 0;

        _forbidden = forbidden.OrderBy(num=>num).ToList();

        // The first jump has to be forward.
        // Can we make the first jump?
        if (_forbidden.BinarySearch(a)>-1)
            return -1;

        _min = 0;

        // Pre sort the forbidden list so we can use a binary search to
        // speed up lookups.

        _jumpForward= a;
        _jumpBackward = b;
        _x = x;

        // This is a test value allocating WAY more than is actually needed
        _max = _x + ((a + b)*5);

        _numberOfJumps = new int?[_max+1];
        _hasJumpedForwardToReachThisSpot = new bool?[_max+1];

        _numberOfJumps[a] = 1;
        _hasJumpedForwardToReachThisSpot[a] = true;

        RecurseJump(a);

        if (_numberOfJumps[_x]==null)
            return -1;

        return _numberOfJumps[_x].Value;
    }

    private void RecurseJump(int currentXPos)
    {
        if (currentXPos == _x)
            return;

        if (CanJumpBackwardFrom(currentXPos))
        {
            var newX = JumpBackward(currentXPos);
            RecurseJump(newX);
        }

        if (CanJumpForwardFrom(currentXPos))
        {
            var newX = JumpForward(currentXPos);
            RecurseJump(newX);
        }
    }


    // Aha! It appears I'm not considering the COST of the jump

    private bool CanJumpForwardFrom(int i)
    {
        var newX = i + _jumpForward;
        return CanJumpTo(i,newX);
    }


    private int JumpForward(int fromPos)
    {

        var newXPos = fromPos + _jumpForward;

        _numberOfJumps[newXPos] = _numberOfJumps[fromPos] + 1;
        _hasJumpedForwardToReachThisSpot[newXPos] = true;

        return newXPos;
    }

    private bool CanJumpBackwardFrom(int i)
    {
        var newX = i - _jumpBackward;
        if (!CanJumpTo(i, newX))
            return false;

        // You can't jump backward twice.
        return (_hasJumpedForwardToReachThisSpot[i] == true);
    }

    private int JumpBackward(int fromPos)
    {
        var newXPos = fromPos - _jumpBackward;

        _numberOfJumps[newXPos] = _numberOfJumps[fromPos] + 1;
        _hasJumpedForwardToReachThisSpot[newXPos] = false;
        return newXPos;
    }


    private bool CanJumpTo(int currentXPos, int newXPos)
    {
        if (newXPos < _min)
        {
            return false;
        }

        if (newXPos > _max)
        {
            return false;
        }

        if (_forbidden.BinarySearch(newXPos)>-1)
        {
            return false;
        }

        var haveJumpedHereAlready = (_numberOfJumps[newXPos] != null);
        if (!haveJumpedHereAlready)
        {
            return true;
        }

        // The DJikstra code I wrote gave me this idea. Let's hope it works.
        var currentCost = _numberOfJumps[currentXPos] ;
        var destinationCost = _numberOfJumps[newXPos];
        var isLessCost = (currentCost+1 < destinationCost);

        return isLessCost;
    }

}
